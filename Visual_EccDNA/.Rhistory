require.entrez = TRUE, remove.dupEntrez = TRUE,
var.filter=TRUE,var.func = IQR, var.cutoff=0.75,
filterByQuantile=TRUE, feature.exclude = "^AFFX")
require(genefilter)
require(hgu133plus2.db)
filtered <- nsFilter(eset_rma,
require.entrez = TRUE, remove.dupEntrez = TRUE,
var.filter=TRUE,var.func = IQR, var.cutoff=0.75,
filterByQuantile=TRUE, feature.exclude = "^AFFX")
install.packages(c("bitops", "haven", "RSQLite"))
require(genefilter)
require(hgu133plus2.db)
filtered <- nsFilter(eset_rma,
require.entrez = TRUE, remove.dupEntrez = TRUE,
var.filter=TRUE,var.func = IQR, var.cutoff=0.75,
filterByQuantile=TRUE, feature.exclude = "^AFFX")
require(pd.hg.u133.plus2.db)
require(hgu133plus2.db)
filtered <- nsFilter(eset_rma,
require.entrez = TRUE, remove.dupEntrez = TRUE,
var.filter=TRUE,var.func = IQR, var.cutoff=0.75,
filterByQuantile=TRUE, feature.exclude = "^AFFX")
BiocManager::install("pd.hg.u133.plus.2.db")
require(pd.hg.u133.plus.2.db)
require(pd.hg.u133.plus.2)
filtered <- nsFilter(eset_rma,
require.entrez = TRUE, remove.dupEntrez = TRUE,
var.filter=TRUE,var.func = IQR, var.cutoff=0.75,
filterByQuantile=TRUE, feature.exclude = "^AFFX")
require(genefilter)
require(pd.hg.u133.plus.2)
filtered <- nsFilter(eset_rma,
require.entrez = TRUE, remove.dupEntrez = TRUE,
var.filter=TRUE,var.func = IQR, var.cutoff=0.75,
filterByQuantile=TRUE, feature.exclude = "^AFFX")
library(pd.hg.u133.plus.2.db)
require(genefilter)
require(pd.hg.u133.plus.2.db)
filtered <- nsFilter(eset_rma,
require.entrez = TRUE, remove.dupEntrez = TRUE,
var.filter=TRUE,var.func = IQR, var.cutoff=0.75,
filterByQuantile=TRUE, feature.exclude = "^AFFX")
require(genefilter)
require(pd.hg.u133.plus.2.db)
annotation(eset_rma) <- "pd.hg.u133.plus.2.db"
filtered <- nsFilter(eset_rma,
require.entrez = TRUE, remove.dupEntrez = TRUE,
var.filter=TRUE,var.func = IQR, var.cutoff=0.75,
filterByQuantile=TRUE, feature.exclude = "^AFFX")
require(genefilter)
require(pd.hg.u133.plus.2.db)
annotation(eset_rma) <- "pd.hg.u133.plus.2.db"
filtered <- nsFilter(eset_rma,
require.entrez = TRUE, remove.dupEntrez = TRUE,
var.filter=TRUE,var.func = IQR, var.cutoff=0.75,
filterByQuantile=TRUE, feature.exclude = "^AFFX")
annotation(eset_rma) <- "pd.hg.u133.plus.2.db"
filtered <- nsFilter(eset_rma,
require.entrez = TRUE, remove.dupEntrez = TRUE,
var.filter=TRUE,var.func = IQR, var.cutoff=0.75,
filterByQuantile=TRUE, feature.exclude = "^AFFX")
require(genefilter)
require(pd.hg.u133.plus.2.db)
annotation(eset_rma) <- "pd.hg.u133.plus.2.db"
filtered <- nsFilter(eset_rma,
require.entrez = TRUE, remove.dupEntrez = TRUE,
var.filter=TRUE,var.func = IQR, var.cutoff=0.75,
filterByQuantile=TRUE, feature.exclude = "^AFFX")
require(genefilter)
require(pd.hg.u133.plus.2.db)
annotation(eset_rma) <- "pd.hg.u133.plus.2.db"
filtered <- nsFilter(eset_rma,
require.entrez = TRUE, remove.dupEntrez = TRUE,
var.filter=TRUE,var.func = IQR, var.cutoff=0.75,
filterByQuantile=TRUE, feature.exclude = "^AFFX")
require(genefilter)
require(pd.hg.u133.plus.2.db)
annotation(eset_rma) <- "pd.hg.u133.plus.2.db"
filtered <- nsFilter(eset_rma,
require.entrez = TRUE, remove.dupEntrez = TRUE,
var.filter=TRUE,var.func = IQR, var.cutoff=0.75,
filterByQuantile=TRUE, feature.exclude = "^AFFX")
require(genefilter)
require(pd.hg.u133.plus.2.db)
annotation(eset_rma) <- "pd.hg.u133.plus.2.db"
filtered <- nsFilter(eset_rma,
require.entrez = TRUE, remove.dupEntrez = TRUE,
var.filter=TRUE,var.func = IQR, var.cutoff=0.75,
filterByQuantile=TRUE, feature.exclude = "^AFFX")
require(genefilter)
require(pd.hg.u133.plus.2.db)
annotation(eset_rma) <- "pd.hg.u133.plus.2.db"
filtered <- nsFilter(eset_rma,
require.entrez = TRUE, remove.dupEntrez = TRUE,
var.filter=TRUE,var.func = IQR, var.cutoff=0.75,
filterByQuantile=TRUE, feature.exclude = "^AFFX")
require(genefilter)
require(pd.hg.u133.plus.2.db)
annotation(eset_rma) <- "pd.hg.u133.plus.2.db"
filtered <- nsFilter(eset_rma,
require.entrez = TRUE, remove.dupEntrez = TRUE,
var.filter=TRUE,var.func = IQR, var.cutoff=0.75,
filterByQuantile=TRUE, feature.exclude = "^AFFX")
require(genefilter)
require(pd.hg.u133.plus.2.db)
annotation(eset_rma) <- "pd.hg.u133.plus.2.db"
filtered <- nsFilter(eset_rma,
require.entrez = TRUE, remove.dupEntrez = TRUE,
var.filter=TRUE,var.func = IQR, var.cutoff=0.75,
filterByQuantile=TRUE, feature.exclude = "^AFFX")
require(genefilter)
require(pd.hg.u133.plus.2.db)
annotation(eset_rma) <- "pd.hg.u133.plus.2.db"
filtered <- nsFilter(eset_rma,
require.entrez = TRUE, remove.dupEntrez = TRUE,
var.filter=TRUE,var.func = IQR, var.cutoff=0.75,
filterByQuantile=TRUE, feature.exclude = "^AFFX")
require(genefilter)
require(pd.hg.u133.plus.2.db)
annotation(eset_rma) <- "pd.hg.u133.plus.2.db"
filtered <- nsFilter(eset_rma,
require.entrez = TRUE, remove.dupEntrez = TRUE,
var.filter=TRUE,var.func = IQR, var.cutoff=0.75,
filterByQuantile=TRUE, feature.exclude = "^AFFX")
require(genefilter)
require(pd.hg.u133.plus.2)
annotation(eset_rma) <- "pd.hg.u133.plus.2.db"
filtered <- nsFilter(eset_rma,
require.entrez = TRUE, remove.dupEntrez = TRUE,
var.filter=TRUE,var.func = IQR, var.cutoff=0.75,
filterByQuantile=TRUE, feature.exclude = "^AFFX")
require(genefilter)
require(pd.hg.u133.plus.2)
annotation(eset_rma) <- "pd.hg.u133.plus.2.db"
filtered <- nsFilter(eset_rma,
require.entrez = TRUE, remove.dupEntrez = TRUE,
var.filter=TRUE,var.func = IQR, var.cutoff=0.75,
filterByQuantile=TRUE, feature.exclude = "^AFFX")
require(genefilter)
require(pd.hg.u133.plus.2.db)
annotation(eset_rma) <- "pd.hg.u133.plus.2.db"
filtered <- nsFilter(eset_rma,
require.entrez = TRUE, remove.dupEntrez = TRUE,
var.filter=TRUE,var.func = IQR, var.cutoff=0.75,
filterByQuantile=TRUE, feature.exclude = "^AFFX")
require(genefilter)
require(pd.hg.u133.plus.2.db)
annotation(eset_rma) <- "pd.hg.u133.plus.2.db"
filtered <- nsFilter(eset_rma,
require.entrez = TRUE, remove.dupEntrez = TRUE,
var.filter=TRUE,var.func = IQR, var.cutoff=0.75,
filterByQuantile=TRUE, feature.exclude = "^AFFX")
require(genefilter)
require(pd.hg.u133.plus.2.db)
require(pd.hg.u133.plus.2)
annotation(eset_rma) <- "pd.hg.u133.plus.2.db"
filtered <- nsFilter(eset_rma,
require.entrez = TRUE, remove.dupEntrez = TRUE,
var.filter=TRUE,var.func = IQR, var.cutoff=0.75,
filterByQuantile=TRUE, feature.exclude = "^AFFX")
require(genefilter)
require(pd.hg.u133.plus.2)
annotation(eset_rma) <- "pd.hg.u133.plus.2.db"
filtered <- nsFilter(eset_rma,
require.entrez = TRUE, remove.dupEntrez = TRUE,
var.filter=TRUE,var.func = IQR, var.cutoff=0.75,
filterByQuantile=TRUE, feature.exclude = "^AFFX")
BiocManager::install("pd.hg.u133.plus.2.db")
shiny::runApp('C:/Users/ainho/eccDNA/Visual EccDNA')
runApp()
runApp('C:/Users/ainho/eccDNA/Visual EccDNA')
runApp()
runApp('C:/Users/ainho/eccDNA/Visual EccDNA')
runApp('C:/Users/ainho/eccDNA/Visual EccDNA')
runApp('C:/Users/ainho/eccDNA/Visual EccDNA')
runApp()
runApp('C:/Users/ainho/eccDNA/Visual EccDNA')
# Remove bad coverage circles and wrong discordant reads outputs
circ <- filter(circ,coverage_cont < 0.5 & discordant_reads < size_bp)
circ <- as.data.frame(read.table("C:/Users/ainho/eccDNA/BED/SRR6315424_unknown_circle.bed",header = FALSE, sep="\t",stringsAsFactors=FALSE))
names(circ) <- c("chr","start","end","discordant_reads","split_reads","score","coverage_mean","coverage_sd","coverage_start", "coverage_end","coverage_cont")
# Add quality levels (score < 10 = Bad, score < 50 = Low, score < 200 = Medium, score > 200 = Good)
circ$quality <- cut(circ$score,breaks=c(-Inf,10,50,200,Inf),labels= c("Bad","Low", "Medium", "Good"),right = FALSE)
# Set chr as factor
circ$chr <- substr(circ$chr, start = 1, stop = 5)
circ$chr<-str_remove(circ$chr,"_")
circ$chr<-str_remove(circ$chr,"chr")
circ$chr <- factor(circ$chr, levels = c("1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","Un","M","X","Y"))
# Add circle id
circ <- circ %>% mutate(circle_id = 1:n()) %>% select(circle_id, everything())
# Add size of circle (number of bp)
size_bp <- circ$end - circ$start
circ<- add_column(circ,size_bp)
View(circ)
shiny::runApp('C:/Users/ainho/eccDNA/Visual EccDNA')
runApp('C:/Users/ainho/eccDNA/Visual EccDNA')
runApp('C:/Users/ainho/eccDNA/Visual EccDNA')
runApp('C:/Users/ainho/eccDNA/Visual EccDNA')
runApp()
runApp('C:/Users/ainho/eccDNA/Visual EccDNA')
runApp('C:/Users/ainho/eccDNA/Visual EccDNA')
runApp()
runApp('C:/Users/ainho/eccDNA/Visual EccDNA')
runApp('C:/Users/ainho/eccDNA/Visual EccDNA')
runApp('C:/Users/ainho/eccDNA/Visual EccDNA')
runApp('C:/Users/ainho/eccDNA/Visual EccDNA')
runApp('C:/Users/ainho/eccDNA/Visual EccDNA')
runApp()
runApp('C:/Users/ainho/eccDNA/Visual EccDNA')
runApp('C:/Users/ainho/eccDNA/Visual EccDNA')
runApp('C:/Users/ainho/eccDNA/Visual EccDNA')
runApp('C:/Users/ainho/eccDNA/Visual EccDNA')
event_data("plotly_click")
runApp('C:/Users/ainho/eccDNA/Visual EccDNA')
runApp()
runApp('C:/Users/ainho/eccDNA/Visual EccDNA')
runApp()
runApp('C:/Users/ainho/eccDNA/Visual EccDNA')
runApp()
runApp('C:/Users/ainho/eccDNA/Visual EccDNA')
shiny::runApp('C:/Users/ainho/eccDNA/Visual EccDNA')
shiny::runApp('C:/Users/ainho/eccDNA/Visual EccDNA')
shiny::runApp('C:/Users/ainho/eccDNA/Visual EccDNA')
shiny::runApp('C:/Users/ainho/eccDNA/Visual_EccDNA')
runApp('C:/Users/ainho/eccDNA/Visual_EccDNA')
server <- function(input, output,session){
# Change options to process bigger files (30MB)
options(shiny.maxRequestSize=30*1024^2)
##### "Get started" tab server functions ####
# TOTAL CIRCLES VALUEBOX
output$total <- renderUI({
# Read data and count()
req(input$bedfile)
circ <-read.table(input$bedfile$datapath,header = FALSE, sep="\t",stringsAsFactors=FALSE)
valueBox(value=circ %>% count(),tags$b("TOTAL DNA CIRCLES"), color="navy",width=6,
icon = tags$i(class = "fas fa-dna", style="color:white"))
})
# RESULTS BUTTON
output$start<-renderUI({
req(input$bedfile)
box(background = "light-blue",height=120,width=4,
tags$b("Click this button to explore your file:"),br(),br(),
actionButton("click","View Results")
)
})
# Enable going to View Results tab after click
observeEvent(input$click, {
newtab <- switch(input$tabs,
"about" = "results")
updateTabItems(session, "tabs", newtab)
})
# QUALITY PLOT
output$quality_gg<-renderUI({
# Read data and add labels
req(input$bedfile)
if (is.null(input$bedfile))
return(NULL)
circ <-read.table(input$bedfile$datapath,header = FALSE, sep="\t",stringsAsFactors=FALSE)
names(circ) <- c("chr","start","end","discordant_reads","split_reads","score","coverage_mean","coverage_sd","coverage_start", "coverage_end","coverage_cont")
# Add quality levels (score < 10 = Bad, score < 50 = Low, score < 200 = Medium, score > 200 = Good)
circ$quality <- cut(circ$score,breaks=c(-Inf,10,50,200,Inf),labels= c("Bad","Low", "Medium", "Good"),right = FALSE)
# Make the box and the plot
box(title="Quality in DNA circles",height=250,renderPlot(
ggplot(circ, aes(x = quality)) +
geom_bar(aes(y = (..count..)/sum(..count..),fill=quality),width=0.4,alpha=0.8,position = position_stack(reverse = TRUE))+
scale_fill_manual(values=c("#FF5733","#FFC300","#DAF7A6","#6EBC63"))+
scale_y_continuous(labels=scales::percent)+
xlab("")+ylab("")+coord_flip()+
theme_minimal()+
guides(fill="none")
,height=200))
})
# DATA TABLE
# Import data from file and add labels
dataframe<-reactive({
if (is.null(input$bedfile))
return(NULL)
circ <-read.table(input$bedfile$datapath,header = FALSE, sep="\t",stringsAsFactors=FALSE)
names(circ) <- c("chr","start","end","discordant_reads","split_reads","score","coverage_mean","coverage_sd","coverage_start", "coverage_end","coverage_cont")
# Add circle id
circ <- circ %>% mutate(circle_id = 1:n()) %>% select(circle_id, everything())
# Add quality levels (score < 10 = Bad, score < 50 = Low, score < 200 = Medium, score > 200 = Good)
circ$quality <- cut(circ$score,breaks=c(-Inf,10,50,200,Inf),labels= c("Bad","Low", "Medium", "Good"),right = FALSE)
# Add size of circle (number of bp)
circ$size_bp <- circ$end - circ$start
circ
})
# Make the data table
output$data <- DT::renderDataTable({
DT::datatable(dataframe(),options = list(
searching = FALSE,
pageLength = 5,
lengthMenu = c(5, 10, 15, 20),
scrollX=TRUE,
columnDefs = list(list(className = 'dt-center', targets = 0:4))
))
})
# Render UI - Appear after file is uploaded
output$table <- renderUI({
req(input$bedfile)
box(width = NULL, solidHeader = TRUE,
dataTableOutput("data"))
})
##### "View Results" tab server functions ####
# PLOT OUTPUT
# Import data and make it reactive
plot_circ <- reactive({
if (is.null(input$bedfile))
return(NULL)
circ <-read.table(input$bedfile$datapath,header = FALSE, sep="\t",stringsAsFactors=FALSE)
names(circ) <- c("chr","start","end","discordant_reads","split_reads","score","coverage_mean","coverage_sd","coverage_start", "coverage_end","coverage_cont")
# Set chromosome as factor and fix random chr
circ$chr <- substr(circ$chr, start = 1, stop = 5)
circ$chr<-str_remove(circ$chr,"_")
circ$chr<-str_remove(circ$chr,"chr")
circ$chr <- factor(circ$chr, levels = c("1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","Un","M","X","Y"))
# Add quality levels (score < 10 = Bad, score < 50 = Low, score < 200 = Medium, score > 200 = Good)
circ$quality <- cut(circ$score,breaks=c(-Inf,10,50,200,Inf),labels= c("Bad","Low", "Medium", "Good"),right = FALSE)
# Add circle id
circ <- circ %>% mutate(circle_id = 1:n()) %>% select(circle_id, everything())
# Add size of circle (number of bp)
circ$size_bp <- circ$end - circ$start
# Remove bad coverage circles and wrong discordant reads outputs
circ <- filter(circ,coverage_cont < 0.5 & discordant_reads < size_bp)
# Incorporate filters input (size and quality)
plot_circ<- filter(circ, between(size_bp, input$size[1], input$size[2]), quality == input$quality)
})
# Plot for circles under 5000bp
output$plot_results <- renderUI({
req(input$bedfile)
box(title="Circles under 5000bp",status="primary", width=8,solidHeader = TRUE,
renderPlotly({
fig <- plot_circ() %>%
plot_ly(type = 'scatter',
source="circleSource",
mode = 'markers',
x = ~chr,
y = ~size_bp,
color = ~chr,
text = ~split_reads,
customdata=~discordant_reads,
hovertemplate = paste("<b>Split Reads: %{text}<br>",
"Discordant Reads: %{customdata}<br>",
"Size: %{y:.0} bp <br>"),
showlegend = FALSE
)
fig <- fig  %>% layout(xaxis = list(
title = "Chromosome of origin"), yaxis = list(title="Size (number of base pairs)"))
fig
})
)
})
# Box of widgets for extra filtering the plot
output$filters<-renderUI({
req(input$bedfile)
box(title="Filters (for plot only)", icon="filter",width=4,status="warning",
sliderInput(inputId = "size",
"By size (number of base pairs):",
min = 50,
max= 5000,
value = c(250,2500)),
checkboxGroupInput(inputId = "quality",
"By quality:",
choices = c("Bad","Low","Medium","Good"),
selected= c("Medium","Good")),
)
})
# TABLE OUTPUT
table_results<-reactive({
if (is.null(input$bedfile))
return(NULL)
circ <-read.table(input$bedfile$datapath,header = FALSE, sep="\t",stringsAsFactors=FALSE)
names(circ) <- c("chr","start","end","discordant_reads","split_reads","score","coverage_mean","coverage_sd","coverage_start", "coverage_end","coverage_cont")
# Add circle id
circ <- circ %>% mutate(circle_id = 1:n()) %>% select(circle_id, everything())
# Add quality levels (score < 10 = Bad, score < 50 = Low, score < 200 = Medium, score > 200 = Good)
circ$quality <- cut(circ$score,breaks=c(-Inf,10,50,200,Inf),labels= c("Bad","Low", "Medium", "Good"),right = FALSE)
# Add size of circle (number of bp)
circ$size_bp <- circ$end - circ$start
# Remove bad coverage circles and outliers with wrong discordant reads outputs
circ <- circ %>%
filter(coverage_cont < 0.5 & size_bp >5000)  %>%
select (circle_id, chr,start,end,discordant_reads,split_reads,score,quality,size_bp)
# Display only some columns
names(circ) <- c("Circle ID", "Original Chromosome","Start","End","Discordant Reads","Split Reads","Score","Quality","Size")
circ
})
# Make the data table for circles over 5000bp
output$bigcircles <- DT::renderDataTable({
DT::datatable(table_results(),options = list(
searching = FALSE,
pageLength = 5,
lengthMenu = c(5, 10, 15, 20),
scrollX=TRUE,
columnDefs = list(list(className = 'dt-center', targets = 0:4))
))
})
# Render UI - Appear after click on the first page
output$table_bigcircles <- renderUI({
req(input$bedfile)
box(title="Circles over 5000bp",status="danger",width = NULL, solidHeader = TRUE,
dataTableOutput("bigcircles"))
})
##### "Circle info" tab server functions ####
observeEvent(event_data("plotly_click",source="circleSource"), {
circletab <- switch(input$tabs,
"results" = "circle")
updateTabItems(session, "tabs", circletab)
})
clickData <- reactive({
currentEventData <- unlist(event_data(event = "plotly_click", source = "circleSource", priority = "event"))
})
output$clickDataOut <- renderText({
paste("Click data:", paste(names(clickData()), unlist(clickData()), sep = ": ", collapse = " | "))
})
observeEvent(event_data("plotly_click",source="circleSource"), {
output$selected_circle<- renderUI({
box(title = "Circle", status="primary",width = 12, solidHeader = TRUE,
htmlOutput("clickDataOut"))
})
})
}
# Load required packages
library(shiny)
library(shinydashboard)
library(tidyverse)
library(plotly)
library(DT)
# User interface
ui <- dashboardPage(
dashboardHeader(title = "Visual EccDNA"),
dashboardSidebar(
sidebarMenu(
id="tabs",
menuItem("Get started",tabName="about",icon=icon("cloud-upload")),
menuItem("View results", tabName ="results", icon=icon("bar-chart")),
menuItem("Circle Info",tabName="circle",icon=icon("circle-o")),
menuItem("GitHub",tabName = "github",icon=icon("github"))
)
),
dashboardBody(
tabItems(
tabItem(
tabName = "about",
fluidRow(
box(
title = "Wellcome to Visual eccDNA", status="primary",width = 12, solidHeader = TRUE,
"This is an app for dynamic data visualization of eccDNA output files. Start selecting a BED file and this page will show an overview of the results. Then you can press the button View Results, and you will be able to see further information about the DNA circles contained in your file."
)),
fluidRow(
box(title= "Upload a Circle BED file with output:",fileInput("bedfile","Choose file:"),status="primary"),
uiOutput("start")
),
fluidRow(uiOutput("total"),
uiOutput("quality_gg")
),
fluidRow(uiOutput("table"))
),
tabItem(
tabName = "results",
fluidRow(uiOutput("plot_results"),
uiOutput("filters")),
fluidRow(uiOutput("table_bigcircles"))
),
tabItem(
tabName="circle",
fluidRow(uiOutput("selected_circle"))
),
tabItem(
tabName="github",
tags$a(href="https://github.com/agarcia18/eccDNA","https://github.com/agarcia18/eccDNA")
)
)
)
)
runApp('C:/Users/ainho/eccDNA/Visual_EccDNA')
runApp('C:/Users/ainho/eccDNA/Visual_EccDNA')
install.packages("bedr")
runApp('C:/Users/ainho/eccDNA/Visual_EccDNA')
library(circlize)
shiny::runApp('C:/Users/ainho/eccDNA/Visual_EccDNA')
runApp('C:/Users/ainho/eccDNA/Visual_EccDNA')
runApp('C:/Users/ainho/eccDNA/Visual_EccDNA')
runApp('C:/Users/ainho/eccDNA/Visual_EccDNA')
runApp('C:/Users/ainho/eccDNA/Visual_EccDNA')
runApp('C:/Users/ainho/eccDNA/Visual_EccDNA')
runApp('C:/Users/ainho/eccDNA/Visual_EccDNA')
options("repos")
options("repos")
# Load required packages
source("data.R")
options("repos")
library(rsconnect)
rsconnect::deployApp('C:/Users/ainho/eccDNA')
library(rsconnect)
rsconnect::deployApp('C:/Users/ainho/eccDNA/Visual_EccDNA')
library(rsconnect)
rsconnect::deployApp('C:/Users/ainho/eccDNA/Visual_EccDNA')
library(rsconnect)
options(rsconnect.http.trace = TRUE, rsconnect.error.trace = TRUE, rsconnect.http.verbose = TRUE)
library(rsconnect)
rsconnect::deployApp('C:/Users/ainho/eccDNA/Visual_EccDNA')
library(rsconnect)
rsconnect::deployApp('C:/Users/ainho/eccDNA/Visual_EccDNA')
shiny::runApp()
library(rsconnect)
rsconnect::deployApp('C:/Users/ainho/eccDNA/Visual_EccDNA')
install.packages(c("affxparser", "affy", "affycoretools", "affyio", "affyPLM", "ALL", "annotate", "AnnotationDbi", "AnnotationFilter", "AnnotationForge", "arrayQualityMetrics", "beadarray", "BeadDataPackR", "BgeeDB", "Biobase", "BiocFileCache", "BiocGenerics", "BiocParallel", "biomaRt", "Biostrings", "biovizBase", "BSgenome", "bumphunter", "Category", "CCl4", "DelayedArray", "DESeq2", "DOSE", "edgeR", "enrichplot", "ensembldb", "estrogen", "fgsea", "gcrma", "genefilter", "geneplotter", "GenomeInfoDb", "GenomeInfoDbData", "GenomicAlignments", "GenomicFeatures", "GenomicRanges", "GEOquery", "ggbio", "Glimma", "GO.db", "GOSemSim", "GOstats", "graph", "graphite", "GSEABase", "illuminaio", "IRanges", "limma", "MatrixGenerics", "multtest", "oligo", "oligoClasses", "org.Hs.eg.db", "org.Mm.eg.db", "OrganismDbi", "PFAM.db", "preprocessCore", "ProtGenerics", "pvca", "qvalue", "RBGL", "RBioinf", "reactome.db", "ReactomePA", "ReportingTools", "Rgraphviz", "Rhtslib", "RITAN", "RITANdata", "Rsamtools", "rtracklayer", "S4Vectors", "STRINGdb", "SummarizedExperiment", "topGO", "VariantAnnotation", "vsn", "XVector", "zlibbioc"))
library(rsconnect)
rsconnect::deployApp('C:/Users/ainho/eccDNA/Visual_EccDNA')
sessionInfo()
options("repos")
